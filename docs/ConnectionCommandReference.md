# MCP Command Reference

This document provides a reference for implementing commands in the game engine that interface with the MCP server.

## Command Structure

All commands share the following structure:

```typescript
{
  id: string; // Unique identifier generated by MCP server
  name: string; // Command name that determines the action
  args: any; // Command-specific arguments
  timestamp: number; // When the command was created
}
```

## Response Structure

All responses must follow this structure:

```typescript
{
  id: string;       // Same ID as the original command
  result: any;      // Result data (if successful)
  error?: string;   // Error message (if failed)
}
```

## Using the MCP Client

To send commands from your TypeScript/JavaScript code:

```typescript
// Example usage from TypeScript
import { connectionController } from "path/to/connectionController";

// Simple command execution
async function teleportPlayer(playerId: number, position: Vector3) {
  const commandId = connectionController.RunCommand("teleportPlayer", {
    playerId,
    positionX: position.x,
    positionY: position.y,
    positionZ: position.z,
  });

  try {
    const result = await connectionController.GetResponce(commandId);
    console.log("Teleport result:", result);
    return result;
  } catch (error) {
    console.error("Failed to teleport player:", error);
    throw error;
  }
}

// Command with timeout handling
async function giveItem(
  playerId: number,
  itemId: string,
  timeoutMs: number = 5000
) {
  const commandId = connectionController.RunCommand("giveItem", {
    playerId,
    itemId,
  });

  // Set up timeout
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      connectionController.CancelCommand(commandId);
      reject(new Error("Command timed out"));
    }, timeoutMs);
  });

  // Race between command completion and timeout
  try {
    const result = await Promise.race([
      connectionController.GetResponce(commandId),
      timeoutPromise,
    ]);
    return result;
  } catch (error) {
    console.error("Failed to give item:", error);
    throw error;
  }
}
```

## Common Command Examples

Below are examples of common commands and their expected arguments and responses.

### Player Management

#### teleportPlayer

Teleports a player to specified coordinates.

**Arguments:**

```json
{
  "playerId": 123456,
  "positionX": 100,
  "positionY": 50,
  "positionZ": 200
}
```

**Success Response:**

```json
{
  "success": true,
  "message": "Player teleported successfully"
}
```

**Error Response:**

```json
{
  "error": "Player not found"
}
```

#### giveItem

Gives an item to a player.

**Arguments:**

```json
{
  "playerId": 123456,
  "itemId": "sword_01",
  "quantity": 1
}
```

**Success Response:**

```json
{
  "success": true,
  "inventorySlot": 3
}
```

### World Management

#### createEntity

Creates an entity in the world.

**Arguments:**

```json
{
  "entityType": "npc",
  "positionX": 100,
  "positionY": 50,
  "positionZ": 200,
  "properties": {
    "name": "Village Guard",
    "health": 100
  }
}
```

**Success Response:**

```json
{
  "entityId": "e-12345",
  "created": true
}
```

#### getWorldData

Gets data about the current world state.

**Arguments:**

```json
{
  "dataType": "players",
  "filters": {
    "inRegion": "spawn"
  }
}
```

**Success Response:**

```json
{
  "players": [
    {
      "id": 123456,
      "name": "Player1",
      "position": [100, 50, 200]
    },
    {
      "id": 123457,
      "name": "Player2",
      "position": [105, 50, 210]
    }
  ],
  "count": 2
}
```

## Error Handling Guidelines

When implementing command handlers in the game engine, follow these error handling guidelines:

1. Always return a result or error for every command
2. Use specific error messages to aid in debugging
3. Handle edge cases gracefully
4. For partial successes, indicate what succeeded and what failed in the result

## Performance Considerations

1. Process commands quickly to avoid timeouts
2. Batch commands when possible to reduce overhead
3. Keep command data minimal to reduce network usage
4. Consider command priority for time-sensitive operations
